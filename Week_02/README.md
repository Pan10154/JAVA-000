# 第二周作业

### 1.使用GCLogAnalysis.java 自己演练一遍串行/并行/CMS/G1的案例

本次测试分部使用了128m,512m,2g,4g 内存:

#### 串行GC:

| MEM  | COUNT | EDEN(m) | FROM(m) | TO(m) | OLD(m) | FGC(ms) | YGC(ms) |
| ---- | ----- | ------- | ------- | ----- | ------ | ------- | ------- |
| 128M | OOM   | 34.9    | 4.3     | 4.3   | 87.4   | 10      | 10      |
| 512M | 11053 | 139.7   | 17.4    | 17.4  | 349.5  | 40      | 20      |
| 2G   | 14497 | 559.2   | 69.8    | 69.8  | 1398.1 | 0       | 58      |
| 4G   | 13721 | 1118.5  | 139.7   | 139.7 | 2796.2 | 0       | 85      |

分析:

​		随着内存的增加, 执行GC的频率越来越低,相对的, 单次执行GC的时间也越来越高,生成对象的次数也随着升高,但是从2g到4g时 ,对象生成的次数降低了.

​		猜想:内存分配速率影响了对象生成次数

使用1g内存启动时:

| MEM  | COUNT | EDEN(m) | FROM(m) | TO(m) | OLD(m) | FGC(ms) | YGC(ms) |
| ---- | ----- | ------- | ------- | ----- | ------ | ------- | ------- |
| 1g   | 14710 | 279.6   | 34.9    | 34.9  | 669.07 | 10      | 30      |

各内存分配速率:

| MEM         | 128M   | 512M | 1G     | 2G     | 4G     |
| ----------- | ------ | ---- | ------ | ------ | ------ |
| HAR(MB/SEC) | 3176.7 | 3584 | 4052.4 | 3938.2 | 3378.8 |

由此可以得出:

​	使用串行GC时 , 在内存升高的同时, 分配速率也在变化 , 而分配速率也影响了对象的产生次数,当内存为1G时 ,分配速率达到最大(测试数据中),产生对象的次数也达到最大 , 而且综合来看, 当内存为1g时 , FGC时间和YGC时间也能达到很小的时间. 由此可以判断,当前环境 使用1G内存 可以让系统达到最优效果(其他环境具体问题具体分析).



#### 并行GC:

| MEM  | COUNT | EDEN(m) | FROM(m) | TO(m) | OLD(m) | FGC(ms) | YGC(ms) |
| ---- | ----- | ------- | ------- | ----- | ------ | ------- | ------- |
| 128M | OOM   | 14.8    | 14.3    | 14.3  | 87.5   | 10      | <10     |
| 512M | 10331 | 58.88   | 57.85   | 57.85 | 349.6  | 30      | 10      |
| 2G   | 15538 | 232.9   | 231.9   | 232.9 | 1398.2 | 0       | 28      |
| 4G   | 15845 | 1048.5  | 174.5   | 174.5 | 2796.5 | 0       | 42.5    |

分析:

​		随着内存的增加, 执行GC的频率越来越低,相对的, 单次执行GC的时间也越来越高,生成对象的次数也随着升高,符合预期.

​		进一步验证:最佳分配速率

因为随着内存升高到4g ,对象次数升高, 所以增加测试5g 和6g

| MEM  | COUNT | EDEN(m) | FROM(m) | TO(m) | OLD(m) | FGC(ms) | YGC(ms) |
| ---- | ----- | ------- | ------- | ----- | ------ | ------- | ------- |
| 5g   | 16091 | 1311.2  | 218.1   | 218.1 | 3495.4 | 0       | 43      |
| 6g   | 15319 | 1572.8  | 262.1   | 262.1 | 4194.3 | 0       | 55      |

各内存分配速率:

| MEM         | 128M   | 512M   | 2G     | 4G     | 5G     | 6G     |
| ----------- | ------ | ------ | ------ | ------ | ------ | ------ |
| HAR(MB/SEC) | 2474.6 | 2441.6 | 4904.6 | 4969.5 | 5676.3 | 5577.5 |

明显可以得出:内存为5G时 ,分配速率达到最高, 且对象次数达到最大,符合预期效果

​	 由此可以判断,当前环境 使用5G内存 可以让系统达到最优效果(其他环境具体问题具体分析).

#### CMS GC:

| MEM  | COUNT | EDEN(m) | FROM(m) | TO(m) | OLD(m) | FGC(ms) | YGC(ms) | Initial(ms) | Final(ms) |
| ---- | ----- | ------- | ------- | ----- | ------ | ------- | ------- | ----------- | --------- |
| 128m | OOM   | 34.9    | 4.3     | 4.3   | 87.4   | 11      | 4       | 0.21        | 0.86      |
| 512m | 12822 | 139.7   | 17.4    | 17.4  | 349.5  | 35      | 15      | 0.15        | 0.85      |
| 2g   | 16760 | 559.2   | 69.8    | 69.8  | 1398.1 | 0       | 44      | 0.2         | 1         |
| 4g   | 17372 | 681.6   | 85.1    | 85.1  | 774.2  | 0       | 45      | 0           | 0         |

由数据可得, 随着内存升高 ,对象次数越高, 发生的YGC和FGC频率越少 , 单位时间越长 , 符合预期 , intial 和final 标记的时间暂时看不出什么规律 ,内存大时,因为old区不需要GC  没有进行标记, 后面再深入了解了

为了得出对象最大次数内存, 使用了5g 和 6g内存再次测试:

| MEM  | COUNT | EDEN(m) | FROM(m) | TO(m) | OLD(m) | FGC(ms) | YGC(ms) | Initial(ms) | Final(ms) |
| ---- | ----- | ------- | ------- | ----- | ------ | ------- | ------- | ----------- | --------- |
| 5g   | 17494 | 681.6   | 85.1    | 85.1  | 4390   | 0       | 45      | 0           | 1         |
| 6g   | 16471 | 681.6   | 85.1    | 85.1  | 5439   | 0       | 48      | 0           | 0         |

明显看出 ,5g时 次数最高

同样 各内存分配速率:

| MEM         | 128M   | 512M | 2G     | 4G     | 5G     | 6G     |
| ----------- | ------ | ---- | ------ | ------ | ------ | ------ |
| HAR(MB/SEC) | 1394.5 | 2811 | 4403.4 | 4868.5 | 4903.5 | 4903.5 |

明显在5g , 6g 时  分配速率达到最高 ,但是,5g内存的次数比6g内存的高, 由此可知 , 除了分配速率外还有其他因素(先排除代码) ,由上课时得到的结论 , 分配速率较低~垃圾回收速率, 这个后面再探究了



#### G1 GC:

| MEM  | COUNT | REGION(K) | FGC(ms) | YGC(ms) |
| ---- | ----- | --------- | ------- | ------- |
| 128M | OOM   | 1024      | 2.2     | 0.68    |
| 512M | 11756 | 1024      | 31      | 2.5     |
| 2G   | 17539 | 1024      | 0       | 18      |
| 4G   | 19501 | 2048      | 0       | 22      |

随着内存增长, gc时间越来越长,符合预期 ,执行中可以发现,G1 使用了并发标记 ,年轻代使用的是标记复制算法,老年代是标记删除.对象生成次数比上述三个GC都要高.

### 2.使用压测工具（wrk或sb），演练gateway-server-0.0.1-SNAPSHOT.jar 示例:

#### 串行GC:

| MEM  | RPS    | Max(ms) | Min(ms) | Avg(ms) |
| ---- | ------ | ------- | ------- | ------- |
| 1G   | 7937.4 | 308     | 0       | 0.1     |
| 2G   | 7964.5 | 358     | 0       | 0.1     |



#### 并行GC:

| MEM  | RPS    | Max(ms) | Min(ms) | Avg(ms) |
| ---- | ------ | ------- | ------- | ------- |
| 1G   | 7643.4 | 274     | 0       | 0.1     |
| 2G   | 8077.1 | 288     | 0       | 0.1     |



#### CMS GC:

| MEM  | RPS    | Max(ms) | Min(ms) | Avg(ms) |
| ---- | ------ | ------- | ------- | ------- |
| 1G   | 8084   | 163     | 0       | 0.1     |
| 2G   | 8085.8 | 232     | 0       | 0.1     |



#### G1 GC:

| MEM  | RPS    | Max(ms) | Min(ms) | Avg(ms) |
| ---- | ------ | ------- | ------- | ------- |
| 1G   | 8107.3 | 280     | 0       | 0.1     |
| 2G   | 7786.3 | 289     | 0       | 0.1     |

整体来看 , 在1-2g 内存时  cms gc 的吞吐量比较高 , 延时最短, 此时串行GC 的不足就明显出来了, 不管是吞吐量还是延时 都不够好  , G1 GC 整体来看 比不上并行GC 和CMS GC  可能是内存还是太小 

  加测4g后:

| GC     | RPS    | Max(ms) | Min(ms) | Avg(ms) |
| ------ | ------ | ------- | ------- | ------- |
| G1     | 7775.2 | 131     | 0       | 0.1     |
| CMS    | 7729   | 249     | 0       | 0.1     |
| 并行GC | 7768.2 | 287     | 0       | 0.1     |

可以得出:4g内存时  G1 GC 吞吐量和其他两个GC 相差不大 , 但是延时却低了很多  , 可见 G1 和 CMS 适用于低延时系统